#include <iostream>
#include <openssl/bn.h>
#include <openssl/ec.h>
#include <cassert>
#include <vector>
#include <chrono>
#include "signer.h"
#include "key_generator.h"

using namespace ring_signature_lib;
using namespace std::chrono;

// 辅助函数：打印 EC_POINT 内容
void print_ec_point(const std::string& label, const EC_GROUP* group, const EC_POINT* point) {
    char* point_str = EC_POINT_point2hex(group, point, POINT_CONVERSION_UNCOMPRESSED, nullptr);
    std::cout << label << ": " << point_str << std::endl;
    OPENSSL_free(point_str);
}

// 辅助函数：打印 BIGNUM 内容
void print_bignum(const std::string& label, const BIGNUM* bn) {
    char* bn_str = BN_bn2hex(bn);
    std::cout << label << ": " << bn_str << std::endl;
    OPENSSL_free(bn_str);
}

// 测试 Sign 函数
void sign_test(int participant_count) {
    auto start_time = high_resolution_clock::now(); // 开始计时

    // 初始化 KeyGenerator
    KeyGenerator keygen;
    std::cout << "Initializing KeyGenerator..." << std::endl;
    keygen.Initialize();
    keygen.SaveConfig();
    std::cout << "KeyGenerator initialized and configuration saved." << std::endl;

    // 初始化消息和事件
    std::string msg = "Test message";
    std::string event = "Test event";
    std::cout << "Message: " << msg << std::endl;
    std::cout << "Event: " << event << std::endl;

    // 初始化多个签名者并生成密钥
    std::vector<Signer> signers;
    for (int i = 0; i < participant_count; ++i) {
        std::string signer_id = "signer" + std::to_string(i + 1);
        std::cout << "\nInitializing " << signer_id << "..." << std::endl;

        // 创建 Signer 实例并初始化
        Signer signer;
        signer.Initialize(signer_id, "config/system_config.json");
        std::cout << signer_id << " initialized." << std::endl;

        // 生成 Signer 的部分密钥
        auto partial_key = signer.GeneratePartialKey();
        print_ec_point("Partial Public Key (X_i) for " + signer_id, signer.GetGroup(), partial_key.second);

        // 使用 KeyGenerator 生成完整密钥所需的签名密钥
        auto [partial_system_public_key, partial_private_key] = keygen.GenerateSignKey(signer_id, partial_key.second);
        print_ec_point("Partial System Public Key for " + signer_id, signer.GetGroup(), partial_system_public_key);

        // 使用 Signer 生成完整密钥
        signer.GenerateFullKey(partial_system_public_key, partial_private_key);
        print_ec_point("Full Public Key (Y_i) for " + signer_id, signer.GetGroup(), signer.GetPublicKey().second);

        // 验证 Signer 密钥的正确性
        assert(signer.VerifyKey() == true);
        std::cout << signer_id << " full key verification passed." << std::endl;

        // 将 signer 添加到列表中
        signers.push_back(signer);
    }

    // 准备 other_signer_pkc 列表用于签名（排除 signer1 自身）
    std::vector<std::pair<std::string, std::pair<EC_POINT*, EC_POINT*>>> other_signer_pkc;
    for (int i = 1; i < participant_count; ++i) {
        other_signer_pkc.emplace_back("signer" + std::to_string(i + 1), signers[i].GetPublicKey());
    }

    std::cout << "Public keys of other signers:" << std::endl;
    for (const auto& [id, pub_key_pair] : other_signer_pkc) {
        print_ec_point(id + " Public Key X", signers[0].GetGroup(), pub_key_pair.first);
        print_ec_point(id + " Public Key Y", signers[0].GetGroup(), pub_key_pair.second);
    }

    // 生成 signer1 的环签名
    std::cout << "Generating ring signature by signer1..." << std::endl;
    auto [A, phi, psi, T] = signers[0].Sign(msg, event, other_signer_pkc);

    // 输出签名结果
    std::cout << "Ring Signature generated by signer1:" << std::endl;
    for (size_t i = 0; i < A.size(); ++i) {
        print_ec_point("A[" + std::to_string(i) + "]", signers[0].GetGroup(), A[i]);
    }
    print_bignum("phi", phi);
    print_bignum("psi", psi);
    print_ec_point("T", signers[0].GetGroup(), T);

    auto end_time = high_resolution_clock::now(); // 结束计时
    auto duration = duration_cast<milliseconds>(end_time - start_time);
    std::cout << "Sign test completed in " << duration.count() << " ms" << std::endl;
}

int main(int argc, char* argv[]) {
    int participant_count = 3; // 默认参与方数量为 3

    // 解析命令行参数
    if (argc > 1) {
        participant_count = std::stoi(argv[1]);
        if (participant_count < 2) {
            std::cerr << "Participant count must be at least 2." << std::endl;
            return 1;
        }
    }

    sign_test(participant_count);
    return 0;
}
